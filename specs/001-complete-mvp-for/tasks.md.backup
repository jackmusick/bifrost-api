# Implementation Tasks: Bifrost Integrations MVP

**Feature**: Bifrost Integrations MVP
**Branch**: `001-complete-mvp-for`
**Generated**: 2025-10-10
**Status**: Ready for implementation

---

## Overview

This document provides a dependency-ordered task list for implementing the Bifrost Integrations MVP. Tasks are organized by user story to enable independent implementation and testing of each feature increment.

**Total Tasks**: 74
**Estimated Complexity**: ~3-4 weeks for full-stack developer
**Testing Strategy**: Test-first development (TDD) - tests before implementation per constitution Principle IV

---

## Task Organization Strategy

Tasks are organized into phases aligned with user stories:

1. **Phase 1: Project Setup** - Repository initialization, tooling, local development environment
2. **Phase 2: Foundational Infrastructure** - Shared components that ALL user stories depend on
3. **Phase 3-6: P1 User Stories** - Core features (Organizations, Auth, Workflows, Execution)
4. **Phase 7-9: P2 User Stories** - User-facing features (Data Providers, Form Builder, Form Renderer)
5. **Phase 10: P3 User Story** - Execution History & Audit Trail
6. **Phase 11: Polish & Integration** - Cross-cutting concerns, documentation, deployment

**MVP Recommendation**: Implement Phases 1-6 (P1 stories only) for minimum viable product.

---

## Phase 1: Project Setup & Local Development

**Goal**: Initialize all three repositories with proper tooling and local development environment

**Independent Test**: Can run all three components locally (client on port 3000, Management API on port 7071, Workflow Engine on port 7072) with Azurite

**Checkpoint**: ✅ All repos initialized, Azurite running, basic "hello world" endpoints functional

### T001 [Setup] - Initialize client repository structure
**File**: `client/` (entire directory structure)
**Description**: Create React + TypeScript project structure with Vite or CRA
**Actions**:
- Run `npm create vite@latest client -- --template react-ts` OR `npx create-react-app client --template typescript`
- Create directory structure: `src/components/`, `src/services/`, `src/types/`, `src/pages/`, `src/hooks/`
- Configure `tsconfig.json` with strict mode
- Add `.env.local.example` with required environment variables
- Create `staticwebapp.config.json` for Azure Static Web Apps routing

**Dependencies**: None
**Test Coverage**: None (project initialization)
**Estimated Time**: 30 minutes

---

### T002 [Setup] - Initialize Management API repository structure
**File**: `management-api/` (separate repo - future)
**Description**: Create Azure Functions Python project for Management API
**Actions**:
- Run `func init management-api --python`
- Create `functions/` directory for HTTP endpoints
- Create `shared/` directory for utilities (storage.py, auth.py, models.py, middleware.py)
- Create `tests/contract/` and `tests/integration/` directories
- Add `requirements.txt` with dependencies: `azure-functions`, `azure-data-tables`, `pydantic`, `azure-identity`, `azure-keyvault-secrets`
- Create `local.settings.json.example`
- Configure `host.json` for Azure Functions v2

**Dependencies**: None
**Test Coverage**: None (project initialization)
**Estimated Time**: 30 minutes

---

### T003 [Setup] - Initialize Workflow Engine repository structure
**File**: `workflow-engine/` (separate repo - future)
**Description**: Create Azure Functions Python project for Workflow Engine
**Actions**:
- Run `func init workflow-engine --python`
- Create `workflows/` directory for workflow functions
- Create `data_providers/` directory for data provider functions
- Create `shared/` directory (decorators.py, context.py, registry.py, storage.py, integrations/)
- Create `admin/` directory for metadata endpoint
- Create `tests/contract/`, `tests/integration/`, `tests/unit/` directories
- Add `requirements.txt` with same dependencies as Management API
- Create `local.settings.json.example`

**Dependencies**: None
**Test Coverage**: None (project initialization)
**Estimated Time**: 30 minutes

---

### T004 [Setup] [P] - Set up Azurite for local Azure Storage emulation
**File**: N/A (local environment)
**Description**: Install and configure Azurite for local Table Storage and Blob Storage
**Actions**:
- Install Azurite: `npm install -g azurite`
- Create startup script: `.specify/scripts/start-azurite.sh`
- Document Azurite connection string in `local.settings.json.example` for both backend repos
- Verify Azurite starts on ports 10000 (Blob), 10001 (Queue), 10002 (Table)

**Dependencies**: None
**Test Coverage**: None (environment setup)
**Estimated Time**: 15 minutes

---

### T005 [Setup] [P] - Configure linting and formatting for all repos
**File**: `client/.eslintrc.json`, `management-api/.flake8`, `workflow-engine/.flake8`
**Description**: Set up code quality tools for consistency
**Actions**:
- Client: Add ESLint + Prettier with TypeScript rules
- Management API: Add `.flake8`, `pyproject.toml` with Black and mypy configs
- Workflow Engine: Add `.flake8`, `pyproject.toml` with Black and mypy configs
- Add pre-commit hooks (optional)

**Dependencies**: T001, T002, T003
**Test Coverage**: None (tooling)
**Estimated Time**: 30 minutes

---

## Phase 2: Foundational Infrastructure

**Goal**: Build shared components that ALL user stories depend on (Table Storage, Auth, Pydantic models)

**Independent Test**: Can create Table Storage entities, validate Azure AD tokens, and use Pydantic models for validation

**Checkpoint**: ✅ TableStorageService working with Azurite, auth middleware validates tokens, all Pydantic models defined

### T006 [Foundation] - Create TableStorageService base class
**File**: `management-api/shared/storage.py`, `workflow-engine/shared/storage.py`
**Description**: Create reusable Table Storage wrapper with org-scoped query helpers
**Actions**:
- Create `TableStorageService` class using `azure-data-tables`
- Implement methods: `insert_entity()`, `update_entity()`, `get_entity()`, `query_entities()`, `delete_entity()`
- Add helper for org-scoped queries: `query_by_org(org_id, row_key_prefix=None)`
- Add helper for dual-indexing: `insert_dual_indexed(entity, partition_keys)` (writes to 2 tables)
- Handle datetime serialization (use `isoformat()` for storage, `fromisoformat()` for retrieval)
- Add connection string loading from environment variables

**Dependencies**: T002, T003
**Test Coverage**: Unit tests for TableStorageService methods (insert, query, update, delete)
**Estimated Time**: 2 hours

---

### T007 [Foundation] - Create all Pydantic models for entities
**File**: `management-api/shared/models.py`, `workflow-engine/shared/models.py`
**Description**: Define Pydantic models for all entities (request/response validation)
**Actions**:
- Create models for: `Organization`, `CreateOrganizationRequest`, `UpdateOrganizationRequest`
- Create models for: `OrgConfig`, `SetConfigRequest`
- Create models for: `UserPermission`, `GrantPermissionsRequest`
- Create models for: `Form`, `FormField`, `FormSchema`, `CreateFormRequest`
- Create models for: `WorkflowExecution`, `WorkflowExecutionRequest`, `WorkflowExecutionResponse`
- Create models for: `WorkflowMetadata`, `WorkflowParameter`, `DataProviderMetadata`
- Add validation rules (min/max length, regex patterns, enums)
- Add type hints for all fields

**Dependencies**: T002, T003
**Test Coverage**: Contract tests for Pydantic model validation (valid/invalid inputs)
**Estimated Time**: 3 hours

---

### T008 [Foundation] - Implement Azure AD token validation middleware
**File**: `management-api/shared/auth.py`
**Description**: Create middleware decorator for Azure AD JWT token validation
**Actions**:
- Create `validate_token()` function using `azure-identity` and JWT validation
- Fetch Azure AD public keys for token signature verification
- Extract user ID from token claims (`oid` or `sub`)
- Create `@require_auth` decorator for protecting endpoints
- Add helper to extract `X-Organization-Id` header
- Raise 401 Unauthorized if token invalid

**Dependencies**: T002
**Test Coverage**: Unit tests for token validation (valid token, expired token, invalid signature)
**Estimated Time**: 2 hours

---

### T009 [Foundation] - Implement permission checking middleware
**File**: `management-api/shared/middleware.py`
**Description**: Create permission enforcement decorators
**Actions**:
- Create `@require_permission(permission_name)` decorator
- Query `UserPermissions` table using `user_id` from token and `org_id` from header
- Check if user has required permission flag (e.g., `CanManageForms`)
- Raise 403 Forbidden if permission denied
- Support permissions: `canExecuteWorkflows`, `canManageConfig`, `canManageForms`, `canViewHistory`

**Dependencies**: T006, T008
**Test Coverage**: Integration tests for permission checks (allowed, denied, missing org access)
**Estimated Time**: 2 hours

---

### T010 [Foundation] - Create Azure Functions blueprint registration system
**File**: `management-api/function_app.py`, `workflow-engine/function_app.py`
**Description**: Set up Azure Functions v2 blueprint pattern for organizing endpoints
**Actions**:
- Create `function_app.py` with `FunctionApp()` initialization
- Import blueprint modules from `functions/` directory
- Register blueprints with `app.register_functions(blueprint)`
- Configure CORS for local development
- Add global error handling

**Dependencies**: T002, T003
**Test Coverage**: None (configuration)
**Estimated Time**: 1 hour

---

### T011 [Foundation] [P] - Create Azure Key Vault client wrapper
**File**: `management-api/shared/secrets.py`, `workflow-engine/shared/secrets.py`
**Description**: Create KeyVaultService for retrieving organization secrets
**Actions**:
- Create `KeyVaultService` class using `azure-keyvault-secrets`
- Implement `get_secret(secret_name)` with caching (request-scoped)
- Support secret naming convention: `{org_id}--{secret_name}`
- Add connection via Managed Identity (Azure) or connection string (local)
- Handle secret not found gracefully

**Dependencies**: T002, T003
**Test Coverage**: Unit tests for secret retrieval (mocked Key Vault)
**Estimated Time**: 1.5 hours

---

## Phase 3: User Story 1 - Organization Management (P1)

**User Story**: An MSP administrator needs to manage client organizations and link them to Microsoft 365 tenants via GDAP to enable automated workflows.

**Goal**: Implement CRUD operations for organizations and organization configuration

**Independent Test**: Can create an organization, link it to a test GDAP tenant, store configuration values, and verify data isolation between organizations.

**Entities**: Organizations, OrgConfig
**Endpoints**: `GET /api/organizations`, `POST /api/organizations`, `GET /api/organizations/{orgId}`, `PATCH /api/organizations/{orgId}`, `DELETE /api/organizations/{orgId}`, `GET /api/organizations/{orgId}/config`, `POST /api/organizations/{orgId}/config`, `DELETE /api/organizations/{orgId}/config/{key}`

**Checkpoint**: ✅ Organizations CRUD working, config storage functional, cross-org data isolation verified

### T012 [US1] - Contract tests for Organizations API
**File**: `management-api/tests/contract/test_organizations_contract.py`
**Description**: Write contract tests for Organizations endpoints (TDD - test first)
**Actions**:
- Test `CreateOrganizationRequest` validation (valid name, invalid name, optional tenantId)
- Test `Organization` response model structure
- Test `UpdateOrganizationRequest` validation
- Test error response models (400, 401, 404)

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for Organizations
**Estimated Time**: 1 hour

---

### T013 [US1] - Implement GET /api/organizations (list all organizations)
**File**: `management-api/functions/organizations.py`
**Description**: Return all organizations the authenticated user has access to
**Actions**:
- Create blueprint with `@bp.route(route="organizations", methods=["GET"])`
- Apply `@require_auth` decorator
- Query `UserPermissions` table by `user_id` to get list of accessible org IDs
- Query `Organizations` table for each org ID (or use batch query)
- Return list of `Organization` models as JSON
- Handle empty result (user has no org access)

**Dependencies**: T006, T008, T009, T010, T012
**Test Coverage**: Integration test with Azurite (create orgs, query as different users)
**Estimated Time**: 1.5 hours

---

### T014 [US1] - Implement POST /api/organizations (create organization)
**File**: `management-api/functions/organizations.py`
**Description**: Create a new client organization
**Actions**:
- Add `@bp.route(route="organizations", methods=["POST"])` to blueprint
- Apply `@require_auth` decorator
- Parse and validate `CreateOrganizationRequest` from request body
- Generate new UUID for organization ID
- Insert entity into `Organizations` table (PartitionKey="ORG", RowKey=org_id)
- Set `CreatedAt`, `CreatedBy`, `UpdatedAt`, `IsActive=True`
- Return created `Organization` model (201 Created)

**Dependencies**: T006, T007, T008, T012
**Test Coverage**: Integration test (create org, verify storage, test validation errors)
**Estimated Time**: 1.5 hours

---

### T015 [US1] [P] - Implement GET /api/organizations/{orgId} (get organization details)
**File**: `management-api/functions/organizations.py`
**Description**: Return details for a specific organization
**Actions**:
- Add `@bp.route(route="organizations/{orgId}", methods=["GET"])` to blueprint
- Apply `@require_auth` decorator
- Extract `orgId` from route parameters
- Check user has permission to access this org (query `UserPermissions`)
- Query `Organizations` table (PartitionKey="ORG", RowKey=orgId)
- Return `Organization` model or 404 Not Found

**Dependencies**: T006, T008, T009, T012
**Test Coverage**: Integration test (get existing org, get non-existent org, unauthorized access)
**Estimated Time**: 1 hour

---

### T016 [US1] [P] - Implement PATCH /api/organizations/{orgId} (update organization)
**File**: `management-api/functions/organizations.py`
**Description**: Update organization name, tenantId, or isActive status
**Actions**:
- Add `@bp.route(route="organizations/{orgId}", methods=["PATCH"])` to blueprint
- Apply `@require_auth` and `@require_permission("canManageConfig")` decorators
- Parse and validate `UpdateOrganizationRequest` from request body
- Get existing organization entity
- Update fields (name, tenantId, isActive)
- Set `UpdatedAt` to current timestamp
- Update entity in Table Storage
- Return updated `Organization` model

**Dependencies**: T006, T007, T008, T009, T012
**Test Coverage**: Integration test (update org, verify changes, test permission denial)
**Estimated Time**: 1.5 hours

---

### T017 [US1] [P] - Implement DELETE /api/organizations/{orgId} (soft delete)
**File**: `management-api/functions/organizations.py`
**Description**: Soft delete organization by setting isActive=False
**Actions**:
- Add `@bp.route(route="organizations/{orgId}", methods=["DELETE"])` to blueprint
- Apply `@require_auth` and `@require_permission("canManageConfig")` decorators
- Get existing organization entity
- Set `IsActive=False` and `UpdatedAt` to current timestamp
- Update entity in Table Storage
- Return 204 No Content

**Dependencies**: T006, T008, T009, T012
**Test Coverage**: Integration test (delete org, verify IsActive=False, verify still queryable)
**Estimated Time**: 1 hour

---

### T018 [US1] - Contract tests for OrgConfig API
**File**: `management-api/tests/contract/test_org_config_contract.py`
**Description**: Write contract tests for OrgConfig endpoints (TDD)
**Actions**:
- Test `SetConfigRequest` validation (key, value, type enum)
- Test `OrgConfig` response model
- Test error responses for invalid type values

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for OrgConfig
**Estimated Time**: 45 minutes

---

### T019 [US1] - Implement GET /api/organizations/{orgId}/config (get all config)
**File**: `management-api/functions/org_config.py`
**Description**: Return all configuration key-value pairs for an organization
**Actions**:
- Create new blueprint for org config endpoints
- Add `@bp.route(route="organizations/{orgId}/config", methods=["GET"])`
- Apply `@require_auth`, `@require_permission("canViewHistory")` decorators
- Extract `orgId` from route and validate `X-Organization-Id` header matches
- Query `OrgConfig` table (PartitionKey=orgId, RowKey starts with "config:")
- Return list of `OrgConfig` models

**Dependencies**: T006, T008, T009, T010, T018
**Test Coverage**: Integration test (get config for org with multiple values, empty config)
**Estimated Time**: 1.5 hours

---

### T020 [US1] - Implement POST /api/organizations/{orgId}/config (set config value)
**File**: `management-api/functions/org_config.py`
**Description**: Create or update a configuration key-value pair
**Actions**:
- Add `@bp.route(route="organizations/{orgId}/config", methods=["POST"])`
- Apply `@require_auth`, `@require_permission("canManageConfig")` decorators
- Parse and validate `SetConfigRequest` from request body
- Create RowKey: `config:{key}`
- Insert or update entity in `OrgConfig` table (PartitionKey=orgId)
- Set `UpdatedAt`, `UpdatedBy` fields
- Return created/updated `OrgConfig` model (201 Created)

**Dependencies**: T006, T007, T008, T009, T018
**Test Coverage**: Integration test (set new config, update existing config, test type validation)
**Estimated Time**: 1.5 hours

---

### T021 [US1] [P] - Implement DELETE /api/organizations/{orgId}/config/{key}
**File**: `management-api/functions/org_config.py`
**Description**: Delete a configuration value
**Actions**:
- Add `@bp.route(route="organizations/{orgId}/config/{key}", methods=["DELETE"])`
- Apply `@require_auth`, `@require_permission("canManageConfig")` decorators
- Extract `orgId` and `key` from route
- Create RowKey: `config:{key}`
- Delete entity from `OrgConfig` table
- Return 204 No Content (even if key didn't exist - idempotent)

**Dependencies**: T006, T008, T009, T018
**Test Coverage**: Integration test (delete existing key, delete non-existent key)
**Estimated Time**: 1 hour

---

### T022 [US1] - Client: Create Organization TypeScript types
**File**: `client/src/types/organization.ts`
**Description**: Define TypeScript interfaces matching API models
**Actions**:
- Create `Organization`, `CreateOrganizationRequest`, `UpdateOrganizationRequest` interfaces
- Create `OrgConfig`, `SetConfigRequest` interfaces
- Export all types

**Dependencies**: T001, T007
**Test Coverage**: None (type definitions)
**Estimated Time**: 30 minutes

---

### T023 [US1] - Client: Create Organization API service
**File**: `client/src/services/apiClient.ts`
**Description**: Create API wrapper for Organizations endpoints
**Actions**:
- Set up Axios instance with base URL from environment variables
- Add request interceptor to include Azure AD token from MSAL
- Implement methods: `getOrganizations()`, `getOrganization(id)`, `createOrganization(data)`, `updateOrganization(id, data)`, `deleteOrganization(id)`
- Implement methods: `getOrgConfig(orgId)`, `setOrgConfig(orgId, data)`, `deleteOrgConfig(orgId, key)`
- Handle errors and return typed responses

**Dependencies**: T001, T022
**Test Coverage**: None (or MSW mock tests)
**Estimated Time**: 2 hours

---

### T024 [US1] - Client: Create useOrganizations custom hook
**File**: `client/src/hooks/useOrganizations.ts`
**Description**: React hook for organization state management
**Actions**:
- Create `useOrganizations()` hook using `useState` and `useEffect`
- Fetch organizations on mount
- Provide methods: `createOrg(data)`, `updateOrg(id, data)`, `deleteOrg(id)`
- Handle loading and error states
- Return `{ organizations, loading, error, createOrg, updateOrg, deleteOrg }`

**Dependencies**: T001, T023
**Test Coverage**: None (or React Testing Library tests)
**Estimated Time**: 1.5 hours

---

### T025 [US1] - Client: Build OrganizationsPage UI component
**File**: `client/src/pages/OrganizationsPage.tsx`
**Description**: Page component for listing and managing organizations
**Actions**:
- Use `useOrganizations()` hook
- Display table/list of organizations with name, tenant ID, status
- Add "Create Organization" button → opens modal/form
- Add edit/delete actions per row
- Handle loading and error states
- Show success/error toasts for operations

**Dependencies**: T001, T024
**Test Coverage**: None (or React Testing Library component tests)
**Estimated Time**: 3 hours

---

### T026 [US1] - Client: Build OrganizationConfigPage UI component
**File**: `client/src/pages/OrganizationConfigPage.tsx`
**Description**: Page for managing organization configuration key-value pairs
**Actions**:
- Accept `orgId` from route parameters
- Display table of config key-value pairs with type
- Add "Add Configuration" button → opens form
- Add edit/delete actions per config row
- Support config types: string, int, bool, json, secret_ref
- Show descriptions and last updated info

**Dependencies**: T001, T023
**Test Coverage**: None
**Estimated Time**: 2.5 hours

---

## Phase 4: User Story 2 - User Authentication & Permissions (P1)

**User Story**: MSP technicians need to log in with their Microsoft 365 accounts and have granular permissions to access specific client organizations.

**Goal**: Implement Azure AD authentication and org-scoped permission management

**Independent Test**: Can create users with different permission sets, attempt to access various organizations, and verify permission enforcement at API level.

**Entities**: Users, UserPermissions, OrgPermissions (dual-indexed)
**Endpoints**: `GET /api/permissions/users/{userId}`, `GET /api/permissions/organizations/{orgId}`, `POST /api/permissions`, `DELETE /api/permissions`

**Checkpoint**: ✅ Azure AD login working, permission CRUD functional, API endpoints enforce permissions

### T027 [US2] - Contract tests for Permissions API
**File**: `management-api/tests/contract/test_permissions_contract.py`
**Description**: Write contract tests for Permissions endpoints (TDD)
**Actions**:
- Test `GrantPermissionsRequest` validation (userId, orgId, permissions object)
- Test `UserPermission` response model
- Test error responses for invalid permission structures

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for permissions
**Estimated Time**: 1 hour

---

### T028 [US2] - Implement GET /api/permissions/users/{userId}
**File**: `management-api/functions/permissions.py`
**Description**: Get all organizations a user can access and their permissions
**Actions**:
- Create blueprint for permissions endpoints
- Add `@bp.route(route="permissions/users/{userId}", methods=["GET"])`
- Apply `@require_auth` decorator
- Ensure requesting user can only query their own permissions (or is admin)
- Query `UserPermissions` table (PartitionKey=userId)
- Return list of `UserPermission` models

**Dependencies**: T006, T008, T010, T027
**Test Coverage**: Integration test (get permissions for user with multiple orgs, user with no orgs)
**Estimated Time**: 1.5 hours

---

### T029 [US2] - Implement GET /api/permissions/organizations/{orgId}
**File**: `management-api/functions/permissions.py`
**Description**: Get all users who have access to an organization
**Actions**:
- Add `@bp.route(route="permissions/organizations/{orgId}", methods=["GET"])`
- Apply `@require_auth`, `@require_permission("canManageConfig")` decorators
- Query `OrgPermissions` table (PartitionKey=orgId)
- Return list of `UserPermission` models

**Dependencies**: T006, T008, T009, T027
**Test Coverage**: Integration test (get users for org, org with no users)
**Estimated Time**: 1.5 hours

---

### T030 [US2] - Implement POST /api/permissions (grant permissions)
**File**: `management-api/functions/permissions.py`
**Description**: Grant a user permissions to access an organization
**Actions**:
- Add `@bp.route(route="permissions", methods=["POST"])`
- Apply `@require_auth`, `@require_permission("canManageConfig")` decorators
- Parse and validate `GrantPermissionsRequest`
- Create permission entity with all 4 permission flags
- Perform DUAL INSERT (atomic if possible):
  - Insert into `UserPermissions` (PartitionKey=userId, RowKey=orgId)
  - Insert into `OrgPermissions` (PartitionKey=orgId, RowKey=userId)
- Set `GrantedBy` and `GrantedAt` fields
- Return created `UserPermission` model (201 Created)

**Dependencies**: T006, T007, T008, T009, T027
**Test Coverage**: Integration test (grant permissions, verify in both tables, test overwrite)
**Estimated Time**: 2 hours

---

### T031 [US2] - Implement DELETE /api/permissions (revoke permissions)
**File**: `management-api/functions/permissions.py`
**Description**: Revoke a user's access to an organization
**Actions**:
- Add `@bp.route(route="permissions", methods=["DELETE"])`
- Apply `@require_auth`, `@require_permission("canManageConfig")` decorators
- Extract `userId` and `orgId` from query parameters
- Perform DUAL DELETE:
  - Delete from `UserPermissions` (PartitionKey=userId, RowKey=orgId)
  - Delete from `OrgPermissions` (PartitionKey=orgId, RowKey=userId)
- Return 204 No Content (idempotent)

**Dependencies**: T006, T008, T009, T027
**Test Coverage**: Integration test (revoke permissions, verify deletion from both tables)
**Estimated Time**: 1.5 hours

---

### T032 [US2] - Client: Set up MSAL authentication provider
**File**: `client/src/services/authService.ts`
**Description**: Configure Azure AD authentication with @azure/msal-react
**Actions**:
- Install `@azure/msal-browser` and `@azure/msal-react`
- Create `PublicClientApplication` with Azure AD config from environment variables
- Export `MsalProvider` wrapper
- Create `useAuth()` hook for login/logout/token access
- Configure scopes for backend APIs

**Dependencies**: T001
**Test Coverage**: None (authentication library)
**Estimated Time**: 2 hours

---

### T033 [US2] - Client: Add authentication wrapper to App component
**File**: `client/src/App.tsx`
**Description**: Wrap app with MSAL provider and handle auth state
**Actions**:
- Import and wrap app with `<MsalProvider>`
- Add `AuthenticatedTemplate` and `UnauthenticatedTemplate` components
- Show login button for unauthenticated users
- Show app content for authenticated users
- Add token refresh logic
- Handle auth errors

**Dependencies**: T001, T032
**Test Coverage**: None
**Estimated Time**: 1.5 hours

---

### T034 [US2] - Client: Create Permission TypeScript types
**File**: `client/src/types/permission.ts`
**Description**: Define TypeScript interfaces for permissions
**Actions**:
- Create `UserPermission`, `GrantPermissionsRequest` interfaces
- Create `PermissionFlags` type with all 4 permission fields

**Dependencies**: T001, T007
**Test Coverage**: None (type definitions)
**Estimated Time**: 15 minutes

---

### T035 [US2] - Client: Create Permissions API service
**File**: `client/src/services/apiClient.ts` (extend existing)
**Description**: Add API wrapper methods for Permissions endpoints
**Actions**:
- Add methods: `getUserPermissions(userId)`, `getOrgPermissions(orgId)`, `grantPermissions(data)`, `revokePermissions(userId, orgId)`
- Include `X-Organization-Id` header where required

**Dependencies**: T023, T034
**Test Coverage**: None
**Estimated Time**: 1 hour

---

### T036 [US2] - Client: Build PermissionsPage UI component
**File**: `client/src/pages/PermissionsPage.tsx`
**Description**: Page for managing user permissions for organizations
**Actions**:
- Display table of users and their permissions per organization
- Add "Grant Permissions" button → opens form (select user, select org, checkboxes for 4 permissions)
- Add revoke action per user-org pair
- Filter by organization
- Show permission flags as checkboxes (read-only or editable)

**Dependencies**: T001, T035
**Test Coverage**: None
**Estimated Time**: 3 hours

---

## Phase 5: User Story 3 - Workflow Development & Registration (P1)

**User Story**: A developer needs to write Python workflows using decorators that automatically register with the platform and expose metadata for form generation.

**Goal**: Implement decorator pattern for workflows with auto-discovery and metadata registration

**Independent Test**: Can create a simple Python workflow with `@workflow` decorator, start workflow engine, and verify workflow appears in metadata endpoint with correct parameter definitions.

**Entities**: Workflow (metadata only - not persisted)
**Endpoints**: `GET /admin/metadata`

**Checkpoint**: ✅ Workflow decorators working, auto-discovery functional, metadata endpoint returns workflow definitions

### T037 [US3] - Create @workflow decorator
**File**: `workflow-engine/shared/decorators.py`
**Description**: Implement decorator for registering workflow functions
**Actions**:
- Create `@workflow(name, description, category, tags=[])` decorator
- Store workflow metadata in global registry (singleton)
- Extract function signature and parameter types
- Support `requires_org=True` flag (default)
- Return decorated function unchanged (for normal Python execution)

**Dependencies**: T003
**Test Coverage**: Unit tests for decorator (register workflow, extract metadata, verify callable)
**Estimated Time**: 2 hours

---

### T038 [US3] - Create @param decorator
**File**: `workflow-engine/shared/decorators.py`
**Description**: Implement decorator for defining workflow parameters with metadata
**Actions**:
- Create `@param(name, type, label=None, required=False, validation=None, data_provider=None, default_value=None, help_text=None)` decorator
- Store parameter metadata in workflow registry
- Support chaining multiple `@param` decorators
- Validate parameter types: string, int, bool, float, json, list

**Dependencies**: T037
**Test Coverage**: Unit tests for parameter decorator (single param, multiple params, validation rules)
**Estimated Time**: 1.5 hours

---

### T039 [US3] - Create workflow metadata registry
**File**: `workflow-engine/shared/registry.py`
**Description**: Singleton registry for storing workflow and data provider metadata
**Actions**:
- Create `WorkflowRegistry` class (singleton pattern)
- Implement methods: `register_workflow(metadata)`, `get_workflow(name)`, `get_all_workflows()`
- Implement methods: `register_data_provider(metadata)`, `get_data_provider(name)`, `get_all_data_providers()`
- Store metadata in memory (dict)
- Thread-safe access (use threading.Lock if needed)

**Dependencies**: T003
**Test Coverage**: Unit tests for registry (register, retrieve, list all)
**Estimated Time**: 1.5 hours

---

### T040 [US3] - Implement workflow auto-discovery system
**File**: `workflow-engine/workflows/__init__.py`
**Description**: Auto-import all workflow modules to trigger decorator registration
**Actions**:
- Use `importlib` to dynamically import all `.py` files in `workflows/` directory
- Skip `__init__.py` and private files (starting with `_`)
- Import happens on module load (when workflow engine starts)
- Log discovered workflows to console

**Dependencies**: T037, T038, T039
**Test Coverage**: Integration test (create dummy workflow file, verify auto-discovery)
**Estimated Time**: 1 hour

---

### T041 [US3] - Implement GET /admin/metadata endpoint
**File**: `workflow-engine/admin/metadata.py`
**Description**: Return metadata for all registered workflows and data providers
**Actions**:
- Create blueprint for admin endpoints
- Add `@bp.route(route="admin/metadata", methods=["GET"])`
- NO authentication required (public metadata endpoint)
- Query `WorkflowRegistry` to get all workflows
- Query `WorkflowRegistry` to get all data providers
- Return `MetadataResponse` model (workflows + dataProviders arrays)

**Dependencies**: T010, T039, T040
**Test Coverage**: Integration test (start workflow engine, call metadata endpoint, verify structure)
**Estimated Time**: 1.5 hours

---

### T042 [US3] - Create example workflow: user_onboarding
**File**: `workflow-engine/workflows/user_onboarding.py`
**Description**: Create example workflow for testing and documentation
**Actions**:
- Create `user_onboarding()` function with `@workflow` decorator
- Add `@param` decorators for: first_name, last_name, email, license
- Implement mock business logic (print or return test data)
- Add docstring explaining workflow purpose
- Accept `OrganizationContext` as first parameter

**Dependencies**: T037, T038
**Test Coverage**: Integration test (execute workflow with mock context, verify output)
**Estimated Time**: 1 hour

---

### T043 [US3] - Create OrganizationContext class
**File**: `workflow-engine/shared/context.py`
**Description**: Context object injected into all workflows
**Actions**:
- Create `OrganizationContext` class with fields: `org_id`, `org_name`, `tenant_id`
- Add method: `get_config(key)` → queries `OrgConfig` table
- Add method: `get_secret(key)` → queries Key Vault via `KeyVaultService`
- Add method: `get_integration(name)` → returns pre-authenticated integration client
- Add method: `log(level, message, data=None)` → writes to execution log
- Cache config and secrets for request duration

**Dependencies**: T003, T006, T011
**Test Coverage**: Unit tests for context methods (get_config, get_secret with mocks)
**Estimated Time**: 2.5 hours

---

### T044 [US3] - Contract tests for Metadata API
**File**: `workflow-engine/tests/contract/test_metadata_contract.py`
**Description**: Write contract tests for metadata endpoint (TDD)
**Actions**:
- Test `MetadataResponse` model structure
- Test `WorkflowMetadata` model (name, description, parameters)
- Test `WorkflowParameter` model (name, type, required, dataProvider)
- Test `DataProviderMetadata` model

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for metadata responses
**Estimated Time**: 1 hour

---

### T045 [US3] - Integration test for workflow registration and execution
**File**: `workflow-engine/tests/integration/test_workflow_execution.py`
**Description**: End-to-end test of workflow registration and execution
**Actions**:
- Create test workflow with `@workflow` and `@param` decorators
- Verify workflow appears in registry
- Execute workflow with mock `OrganizationContext`
- Verify workflow receives correct parameters
- Verify workflow can access context methods
- Test workflow with `requires_org=False`

**Dependencies**: T037, T038, T039, T040, T042, T043
**Test Coverage**: Integration test for full workflow lifecycle
**Estimated Time**: 2 hours

---

## Phase 6: User Story 7 - Workflow Execution with Organization Context (P1)

**User Story**: Workflows need to automatically receive organization context including config, secrets, and pre-authenticated integration clients when executed.

**Goal**: Implement workflow execution endpoint with automatic context loading

**Independent Test**: Can execute a workflow that accesses organization config, retrieves a secret, and uses an integration client, verifying all context is correctly loaded.

**Entities**: WorkflowExecutions, UserExecutions (dual-indexed)
**Endpoints**: `POST /workflows/{workflowName}`

**Checkpoint**: ✅ Workflows can be executed via HTTP, context is automatically loaded, executions are logged to Table Storage

### T046 [US7] - Create context loading middleware
**File**: `workflow-engine/shared/middleware.py`
**Description**: Decorator for loading OrganizationContext from request headers
**Actions**:
- Create `@with_org_context` decorator
- Extract `X-Organization-Id` header from request
- Query `Organizations` table to get org details
- Query `OrgConfig` table to load all config (PartitionKey=org_id)
- Create `OrganizationContext` object with org details and config
- Inject context into route handler function
- Handle missing header or invalid org ID (400 Bad Request)

**Dependencies**: T006, T043
**Test Coverage**: Unit tests for context loading (valid org, invalid org, missing header)
**Estimated Time**: 2 hours

---

### T047 [US7] - Create base integration client class
**File**: `workflow-engine/shared/integrations/base.py`
**Description**: Base class for all integration clients
**Actions**:
- Create `BaseIntegration` abstract class
- Accept `OrganizationContext` in constructor
- Define abstract method: `authenticate()` → returns access token
- Add helper method: `_get_secret(key)` → calls `context.get_secret(key)`
- Add helper method: `_get_config(key)` → calls `context.get_config(key)`

**Dependencies**: T003, T043
**Test Coverage**: None (abstract class)
**Estimated Time**: 45 minutes

---

### T048 [US7] [P] - Create Microsoft Graph integration client
**File**: `workflow-engine/shared/integrations/msgraph.py`
**Description**: Pre-authenticated Microsoft Graph API client
**Actions**:
- Extend `BaseIntegration`
- Implement `authenticate()` using MSAL with client credentials flow
- Retrieve credentials from config/secrets: `msgraph_client_id`, `msgraph_client_secret`, `tenant_id`
- Create HTTP client wrapper for Graph API calls
- Add common methods: `get_users()`, `create_user()`, `assign_license()`, `get_subscribed_skus()`
- Cache access token in context for request duration

**Dependencies**: T043, T047
**Test Coverage**: Unit tests with mocked Graph API responses
**Estimated Time**: 3 hours

---

### T049 [US7] [P] - Create HaloPSA integration client
**File**: `workflow-engine/shared/integrations/halopsa.py`
**Description**: Pre-authenticated HaloPSA API client
**Actions**:
- Extend `BaseIntegration`
- Implement `authenticate()` using HaloPSA OAuth2 flow
- Retrieve credentials from config/secrets: `halopsa_client_id`, `halopsa_client_secret`, `halopsa_api_url`
- Create HTTP client wrapper for HaloPSA API calls
- Add common methods: `get_tickets()`, `create_ticket()`, `update_ticket()`
- Cache access token

**Dependencies**: T043, T047
**Test Coverage**: Unit tests with mocked HaloPSA responses
**Estimated Time**: 2.5 hours

---

### T050 [US7] - Add get_integration() method to OrganizationContext
**File**: `workflow-engine/shared/context.py`
**Description**: Factory method for creating integration clients
**Actions**:
- Add `get_integration(name: str)` method to `OrganizationContext`
- Support integration names: "msgraph", "halopsa"
- Instantiate appropriate integration class with `self` as context
- Call `authenticate()` on integration before returning
- Cache integration instances for request duration
- Raise error if integration name not recognized

**Dependencies**: T043, T048, T049
**Test Coverage**: Unit tests for get_integration (msgraph, halopsa, invalid name)
**Estimated Time**: 1 hour

---

### T051 [US7] - Contract tests for Workflow Execution API
**File**: `workflow-engine/tests/contract/test_execution_contract.py`
**Description**: Write contract tests for workflow execution endpoint (TDD)
**Actions**:
- Test `WorkflowExecutionRequest` validation (parameters, metadata)
- Test `WorkflowExecutionResponse` model (executionId, status, result, error)
- Test error responses (400, 404, 500)

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for execution requests/responses
**Estimated Time**: 1 hour

---

### T052 [US7] - Implement POST /workflows/{workflowName} (execute workflow)
**File**: `workflow-engine/function_app.py` (or `functions/execute.py`)
**Description**: Execute a workflow with provided parameters and org context
**Actions**:
- Add `@bp.route(route="workflows/{workflowName}", methods=["POST"])`
- Apply `@require_auth` (from T008), `@with_org_context` (from T046), `@require_permission("canExecuteWorkflows")` decorators
- Extract `workflowName` from route
- Get workflow metadata from registry
- Parse and validate `WorkflowExecutionRequest`
- Generate execution ID (UUID)
- Create execution record in `WorkflowExecutions` table (status="Pending")
- Invoke workflow function with context + parameters
- Update execution record with result/error and status ("Success" or "Failed")
- Also insert into `UserExecutions` table (dual-indexing)
- Return `WorkflowExecutionResponse` (200 for success, 500 for failure with error message)

**Dependencies**: T006, T008, T009, T039, T043, T046, T051
**Test Coverage**: Integration test (execute workflow, verify execution logged, verify context passed correctly)
**Estimated Time**: 4 hours

---

### T053 [US7] - Implement execution logging to Table Storage
**File**: `workflow-engine/shared/execution_logger.py`
**Description**: Helper for logging workflow execution details
**Actions**:
- Create `ExecutionLogger` class
- Implement `create_execution(org_id, workflow_name, executed_by, input_data)` → returns execution_id
- Implement `update_execution(execution_id, status, result=None, error_message=None, duration_ms=None)`
- Handle dual-indexing: write to `WorkflowExecutions` (by org) and `UserExecutions` (by user)
- Calculate reverse timestamp for RowKey
- Store InputData and Result as JSON strings
- Handle large results (>32KB) → store in Blob Storage, reference in table

**Dependencies**: T006
**Test Coverage**: Unit tests for execution logging (create, update, dual-index)
**Estimated Time**: 2.5 hours

---

### T054 [US7] - Integration test for workflow execution with context
**File**: `workflow-engine/tests/integration/test_workflow_with_context.py`
**Description**: Test workflow execution with full organization context
**Actions**:
- Set up test organization in Table Storage (via Azurite)
- Add test config values to `OrgConfig` table
- Mock Key Vault secret retrieval
- Execute workflow that uses `context.get_config()` and `context.get_secret()`
- Verify workflow receives correct config and secrets
- Verify execution is logged in both `WorkflowExecutions` and `UserExecutions` tables
- Test workflow failure handling (exception → status="Failed")

**Dependencies**: T043, T046, T052, T053
**Test Coverage**: Integration test for full workflow execution flow
**Estimated Time**: 2.5 hours

---

## Phase 7: User Story 4 - Data Providers for Dynamic Form Fields (P2)

**User Story**: Developers need to create data provider functions that supply dynamic options for form fields.

**Goal**: Implement decorator pattern for data providers with auto-discovery and execution endpoint

**Independent Test**: Can create a data provider that returns a list of items, create a form field that references it, and verify the form receives the correct options when rendered.

**Entities**: DataProvider (metadata only - not persisted)
**Endpoints**: `GET /data-providers/{providerName}`

**Checkpoint**: ✅ Data provider decorators working, auto-discovery functional, data provider endpoint returns options

### T055 [US4] - Create @data_provider decorator
**File**: `workflow-engine/shared/decorators.py`
**Description**: Implement decorator for registering data provider functions
**Actions**:
- Create `@data_provider(name, description, category="", cache_ttl_seconds=0)` decorator
- Store data provider metadata in registry
- Return decorated function unchanged
- Support cache TTL for performance

**Dependencies**: T039
**Test Coverage**: Unit tests for data_provider decorator (register, extract metadata)
**Estimated Time**: 1.5 hours

---

### T056 [US4] - Implement data provider auto-discovery
**File**: `workflow-engine/data_providers/__init__.py`
**Description**: Auto-import all data provider modules to trigger registration
**Actions**:
- Use `importlib` to import all `.py` files in `data_providers/` directory
- Skip `__init__.py` and private files
- Log discovered data providers

**Dependencies**: T055
**Test Coverage**: Integration test (create dummy data provider, verify auto-discovery)
**Estimated Time**: 45 minutes

---

### T057 [US4] - Create example data provider: get_available_licenses
**File**: `workflow-engine/data_providers/get_available_licenses.py`
**Description**: Example data provider for M365 license options
**Actions**:
- Create `get_available_licenses()` function with `@data_provider` decorator
- Accept `OrganizationContext` as parameter
- Use `context.get_integration("msgraph")` to fetch subscribed SKUs
- Filter to available licenses (consumedUnits < prepaidUnits)
- Return list of `{"label": "M365 E5 (15 available)", "value": "sku-id"}` dicts
- Add error handling for Graph API failures

**Dependencies**: T043, T048, T055
**Test Coverage**: Unit test with mocked Graph API
**Estimated Time**: 1.5 hours

---

### T058 [US4] - Contract tests for Data Provider API
**File**: `workflow-engine/tests/contract/test_data_provider_contract.py`
**Description**: Write contract tests for data provider endpoint (TDD)
**Actions**:
- Test `DataProviderResponse` model (options array, cached flag)
- Test option structure: `{"label": string, "value": any, "metadata"?: object}`
- Test error responses

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for data provider responses
**Estimated Time**: 45 minutes

---

### T059 [US4] - Implement GET /data-providers/{providerName}
**File**: `workflow-engine/functions/data_providers.py` (or in function_app.py)
**Description**: Execute a data provider and return options
**Actions**:
- Add `@bp.route(route="data-providers/{providerName}", methods=["GET"])`
- Apply `@require_auth`, `@with_org_context` decorators
- Extract `providerName` from route
- Get data provider metadata from registry
- Execute data provider function with context
- Cache result if `cache_ttl_seconds > 0` (in-memory cache with expiration)
- Return `DataProviderResponse` (options + cached flag)
- Handle data provider exceptions gracefully (500 error with message)

**Dependencies**: T008, T039, T046, T055, T058
**Test Coverage**: Integration test (execute data provider, verify options, test caching)
**Estimated Time**: 2.5 hours

---

### T060 [US4] - Integration test for data provider execution
**File**: `workflow-engine/tests/integration/test_data_provider_execution.py`
**Description**: Test data provider execution with organization context
**Actions**:
- Create test data provider that uses context.get_config()
- Execute data provider via endpoint
- Verify correct options returned
- Test caching behavior (call twice, verify cached flag)
- Test data provider failure handling

**Dependencies**: T055, T056, T057, T059
**Test Coverage**: Integration test for data provider lifecycle
**Estimated Time**: 1.5 hours

---

## Phase 8: User Story 5 - Form Builder (P2)

**User Story**: An MSP administrator needs to create forms with various field types that are linked to workflows and use data providers for dynamic fields.

**Goal**: Implement form CRUD operations with JSON schema storage

**Independent Test**: Can create a form with multiple field types (text, email, select, checkbox), link it to a workflow, and verify the form can be saved and retrieved.

**Entities**: Forms
**Endpoints**: `GET /api/forms`, `POST /api/forms`, `GET /api/forms/{formId}`, `PUT /api/forms/{formId}`, `DELETE /api/forms/{formId}`

**Checkpoint**: ✅ Forms CRUD working, form schema validation functional, forms can reference data providers

### T061 [US5] - Contract tests for Forms API
**File**: `management-api/tests/contract/test_forms_contract.py`
**Description**: Write contract tests for Forms endpoints (TDD)
**Actions**:
- Test `CreateFormRequest` validation (name, linkedWorkflow, formSchema)
- Test `Form` response model
- Test `FormSchema` structure (fields array)
- Test `FormField` validation (name, type enum, required, validation object, dataProvider)
- Test error responses

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for forms
**Estimated Time**: 1.5 hours

---

### T062 [US5] - Implement GET /api/forms (list forms)
**File**: `management-api/functions/forms.py`
**Description**: Return all forms for an organization plus global forms
**Actions**:
- Create blueprint for forms endpoints
- Add `@bp.route(route="forms", methods=["GET"])`
- Apply `@require_auth` decorator
- Extract `X-Organization-Id` from header
- Query `Forms` table for org-specific forms (PartitionKey=org_id)
- Query `Forms` table for global forms (PartitionKey="GLOBAL")
- Merge results and return as array of `Form` models

**Dependencies**: T006, T008, T010, T061
**Test Coverage**: Integration test (list org forms, list global forms, combined list)
**Estimated Time**: 1.5 hours

---

### T063 [US5] - Implement POST /api/forms (create form)
**File**: `management-api/functions/forms.py`
**Description**: Create a new form for an organization
**Actions**:
- Add `@bp.route(route="forms", methods=["POST"])`
- Apply `@require_auth`, `@require_permission("canManageForms")` decorators
- Parse and validate `CreateFormRequest`
- Validate `formSchema` JSON structure (parse and validate against schema)
- Validate `linkedWorkflow` exists (call Workflow Engine metadata endpoint)
- Generate form ID (UUID)
- Insert into `Forms` table (PartitionKey=org_id OR "GLOBAL", RowKey=form_id)
- Set CreatedBy, CreatedAt, UpdatedAt, IsActive=True
- Return created `Form` model (201 Created)

**Dependencies**: T006, T007, T008, T009, T061
**Test Coverage**: Integration test (create form, validate schema, test invalid workflow link)
**Estimated Time**: 2.5 hours

---

### T064 [US5] [P] - Implement GET /api/forms/{formId} (get form details)
**File**: `management-api/functions/forms.py`
**Description**: Return details for a specific form
**Actions**:
- Add `@bp.route(route="forms/{formId}", methods=["GET"])`
- Apply `@require_auth` decorator
- Extract `formId` from route and `X-Organization-Id` from header
- Try to get form from org partition OR GLOBAL partition
- Parse `FormSchema` JSON string into object before returning
- Return `Form` model or 404 Not Found

**Dependencies**: T006, T008, T061
**Test Coverage**: Integration test (get org form, get global form, get non-existent form)
**Estimated Time**: 1.5 hours

---

### T065 [US5] [P] - Implement PUT /api/forms/{formId} (update form)
**File**: `management-api/functions/forms.py`
**Description**: Update an existing form
**Actions**:
- Add `@bp.route(route="forms/{formId}", methods=["PUT"])`
- Apply `@require_auth`, `@require_permission("canManageForms")` decorators
- Parse and validate `CreateFormRequest` (full replacement)
- Get existing form entity
- Validate new `formSchema` and `linkedWorkflow`
- Update entity fields (name, description, formSchema, linkedWorkflow)
- Set UpdatedAt to current timestamp
- Update entity in Table Storage
- Return updated `Form` model

**Dependencies**: T006, T007, T008, T009, T061
**Test Coverage**: Integration test (update form, verify changes, test validation)
**Estimated Time**: 2 hours

---

### T066 [US5] [P] - Implement DELETE /api/forms/{formId} (delete form)
**File**: `management-api/functions/forms.py`
**Description**: Soft delete a form by setting isActive=False
**Actions**:
- Add `@bp.route(route="forms/{formId}", methods=["DELETE"])`
- Apply `@require_auth`, `@require_permission("canManageForms")` decorators
- Get existing form entity
- Set IsActive=False and UpdatedAt
- Update entity
- Return 204 No Content

**Dependencies**: T006, T008, T009, T061
**Test Coverage**: Integration test (delete form, verify IsActive=False)
**Estimated Time**: 1 hour

---

### T067 [US5] - Client: Create Form TypeScript types
**File**: `client/src/types/form.ts`
**Description**: Define TypeScript interfaces for forms
**Actions**:
- Create `Form`, `CreateFormRequest`, `FormSchema`, `FormField` interfaces
- Create enum for field types: `text | email | number | select | checkbox | textarea`
- Export all types

**Dependencies**: T001, T007
**Test Coverage**: None (type definitions)
**Estimated Time**: 30 minutes

---

### T068 [US5] - Client: Create Forms API service
**File**: `client/src/services/apiClient.ts` (extend)
**Description**: Add API wrapper methods for Forms endpoints
**Actions**:
- Add methods: `getForms()`, `getForm(id)`, `createForm(data)`, `updateForm(id, data)`, `deleteForm(id)`
- Include `X-Organization-Id` header

**Dependencies**: T023, T067
**Test Coverage**: None
**Estimated Time**: 1 hour

---

### T069 [US5] - Client: Create useForms custom hook
**File**: `client/src/hooks/useForms.ts`
**Description**: React hook for form state management
**Actions**:
- Create `useForms()` hook
- Fetch forms on mount
- Provide methods: `createForm(data)`, `updateForm(id, data)`, `deleteForm(id)`
- Handle loading and error states
- Return `{ forms, loading, error, createForm, updateForm, deleteForm }`

**Dependencies**: T001, T068
**Test Coverage**: None
**Estimated Time**: 1.5 hours

---

### T070 [US5] - Client: Build FormBuilderPage UI component
**File**: `client/src/pages/FormBuilderPage.tsx`
**Description**: Page for creating and editing forms
**Actions**:
- Accept optional `formId` from route (edit mode vs. create mode)
- Display form metadata fields: name, description, linkedWorkflow (dropdown from metadata)
- Display field builder section:
  - List of added fields with drag-and-drop reordering
  - "Add Field" button → opens field editor
  - Field editor form: name, label, type (dropdown), required (checkbox), validation rules, dataProvider (dropdown from metadata), defaultValue, placeholder, helpText
- Implement field type-specific options (e.g., dataProvider only for select fields)
- Save button → validates and submits form
- Preview section showing how form will render

**Dependencies**: T001, T069
**Test Coverage**: None
**Estimated Time**: 5 hours

---

### T071 [US5] - Client: Fetch and cache workflow metadata
**File**: `client/src/services/workflowClient.ts`
**Description**: Create client for Workflow Engine API
**Actions**:
- Create Axios instance for Workflow Engine base URL
- Add auth interceptor (same as Management API)
- Implement `getMetadata()` method → fetches `/admin/metadata`
- Cache metadata in memory or React Context
- Parse workflows and data providers for form builder dropdowns

**Dependencies**: T001
**Test Coverage**: None
**Estimated Time**: 1.5 hours

---

## Phase 9: User Story 6 - Form Renderer & Submission (P2)

**User Story**: An MSP technician needs to view and submit forms to execute workflows, with dynamic field options loaded from data providers.

**Goal**: Implement form rendering with validation and workflow execution

**Independent Test**: Can render a form, fill in fields (including a select field with dynamic options), submit it, and verify the workflow is executed with the correct parameters.

**Entities**: None (uses Forms from US5, triggers Workflows from US7)
**Endpoints**: Uses existing `GET /api/forms/{formId}`, `POST /workflows/{workflowName}`, `GET /data-providers/{providerName}`

**Checkpoint**: ✅ Forms render correctly, data providers populate select fields, form submission executes workflows

### T072 [US6] - Client: Create FormRenderer component
**File**: `client/src/components/forms/FormRenderer.tsx`
**Description**: Component for rendering and validating forms
**Actions**:
- Accept `form: Form` as prop
- Parse `formSchema` to get field definitions
- Render field for each type:
  - text → `<input type="text">`
  - email → `<input type="email">`
  - number → `<input type="number">`
  - select → `<select>` with options from data provider
  - checkbox → `<input type="checkbox">`
  - textarea → `<textarea>`
- Implement client-side validation (required, pattern, min/max)
- Show inline validation errors
- For select fields with `dataProvider`, fetch options on mount from `GET /data-providers/{providerName}`
- Handle loading state for data provider queries
- Disable submit until all validations pass
- Emit `onSubmit(formData)` event with field values as object

**Dependencies**: T001, T067, T071
**Test Coverage**: None (or React Testing Library component tests)
**Estimated Time**: 4 hours

---

### T073 [US6] - Client: Create FormSubmissionPage UI component
**File**: `client/src/pages/FormSubmissionPage.tsx`
**Description**: Page for submitting forms and executing workflows
**Actions**:
- Accept `formId` from route parameters
- Fetch form details using `getForm(formId)`
- Render form using `<FormRenderer>`
- Handle form submission:
  - Extract form data
  - Call `POST /workflows/{linkedWorkflow}` with parameters from form data
  - Include `X-Organization-Id` header (from organization selector)
  - Show loading spinner during execution
  - Display execution result (success message + result data OR error message)
  - Provide execution ID for tracking
- Add "Submit Another" button to reset form

**Dependencies**: T001, T068, T071, T072
**Test Coverage**: None
**Estimated Time**: 3 hours

---

### T074 [US6] - Client: Add organization selector to navigation
**File**: `client/src/components/common/OrganizationSelector.tsx`
**Description**: Dropdown for selecting active organization (sets X-Organization-Id)
**Actions**:
- Fetch user's accessible organizations on mount
- Display dropdown in app header/nav
- Store selected org ID in React Context or state
- Automatically include selected org ID in `X-Organization-Id` header for all API requests (via Axios interceptor)
- Show org name in dropdown
- Persist selection in localStorage

**Dependencies**: T001, T023
**Test Coverage**: None
**Estimated Time**: 2 hours

---

## Phase 10: User Story 8 - Execution History & Audit Trail (P3)

**User Story**: MSP technicians need to view a history of workflow executions to monitor automation activity, troubleshoot issues, and maintain an audit trail.

**Goal**: Implement execution history queries and detail views

**Independent Test**: Can execute several workflows, then query execution history and verify all executions are recorded with correct timestamps, status, and details.

**Entities**: WorkflowExecutions, UserExecutions (already created in US7)
**Endpoints**: `GET /api/executions`, `GET /api/executions/{executionId}`, `GET /api/executions/users/{userId}`

**Checkpoint**: ✅ Execution history queries working, filtering functional, execution details viewable

### T075 [US8] - Contract tests for Executions API
**File**: `management-api/tests/contract/test_executions_contract.py`
**Description**: Write contract tests for Executions endpoints (TDD)
**Actions**:
- Test `WorkflowExecution` response model
- Test query parameter validation (status enum, limit range)

**Dependencies**: T007
**Test Coverage**: Pydantic model validation for executions
**Estimated Time**: 45 minutes

---

### T076 [US8] - Implement GET /api/executions (list executions for org)
**File**: `management-api/functions/executions.py`
**Description**: Return execution history for an organization with filtering
**Actions**:
- Create blueprint for executions endpoints
- Add `@bp.route(route="executions", methods=["GET"])`
- Apply `@require_auth`, `@require_permission("canViewHistory")` decorators
- Extract `X-Organization-Id` from header
- Extract query parameters: `status`, `workflowName`, `limit` (default=50, max=200)
- Query `WorkflowExecutions` table (PartitionKey=org_id)
- Filter by status and workflowName if provided
- Limit results (take first N)
- Return array of `WorkflowExecution` models (newest first due to reverse timestamp)

**Dependencies**: T006, T008, T009, T010, T075
**Test Coverage**: Integration test (list executions, filter by status, filter by workflow)
**Estimated Time**: 2 hours

---

### T077 [US8] [P] - Implement GET /api/executions/{executionId} (get execution details)
**File**: `management-api/functions/executions.py`
**Description**: Return full details for a specific execution
**Actions**:
- Add `@bp.route(route="executions/{executionId}", methods=["GET"])`
- Apply `@require_auth`, `@require_permission("canViewHistory")` decorators
- Extract `executionId` from route
- Extract `X-Organization-Id` from header (to determine RowKey with reverse timestamp)
- Query `WorkflowExecutions` table (scan if necessary - execution ID is not in RowKey directly)
- Parse InputData and Result JSON strings into objects
- Return `WorkflowExecution` model or 404 Not Found

**Dependencies**: T006, T008, T009, T075
**Test Coverage**: Integration test (get execution, get non-existent execution)
**Estimated Time**: 1.5 hours

---

### T078 [US8] [P] - Implement GET /api/executions/users/{userId} (user execution history)
**File**: `management-api/functions/executions.py`
**Description**: Return all executions by a user across all authorized organizations
**Actions**:
- Add `@bp.route(route="executions/users/{userId}", methods=["GET"])`
- Apply `@require_auth` decorator
- Ensure requesting user can only query their own executions (or is admin)
- Extract query parameter: `limit` (default=50, max=200)
- Query `UserExecutions` table (PartitionKey=userId)
- Limit results
- Return array of `WorkflowExecution` models (summary data from UserExecutions table)

**Dependencies**: T006, T008, T075
**Test Coverage**: Integration test (get user executions across multiple orgs)
**Estimated Time**: 1.5 hours

---

### T079 [US8] - Client: Create Execution TypeScript types
**File**: `client/src/types/execution.ts`
**Description**: Define TypeScript interfaces for executions
**Actions**:
- Create `WorkflowExecution` interface
- Create enum for status: `Pending | Running | Success | Failed`
- Export types

**Dependencies**: T001, T007
**Test Coverage**: None (type definitions)
**Estimated Time**: 15 minutes

---

### T080 [US8] - Client: Create Executions API service
**File**: `client/src/services/apiClient.ts` (extend)
**Description**: Add API wrapper methods for Executions endpoints
**Actions**:
- Add methods: `getExecutions(orgId, filters)`, `getExecution(executionId, orgId)`, `getUserExecutions(userId, limit)`
- Include `X-Organization-Id` header

**Dependencies**: T023, T079
**Test Coverage**: None
**Estimated Time**: 1 hour

---

### T081 [US8] - Client: Create useExecutions custom hook
**File**: `client/src/hooks/useExecutions.ts`
**Description**: React hook for execution history state
**Actions**:
- Create `useExecutions(orgId, filters)` hook
- Fetch executions on mount and when filters change
- Support filtering by status and workflow name
- Handle loading and error states
- Return `{ executions, loading, error, refetch }`

**Dependencies**: T001, T080
**Test Coverage**: None
**Estimated Time**: 1 hour

---

### T082 [US8] - Client: Build ExecutionHistoryPage UI component
**File**: `client/src/pages/ExecutionHistoryPage.tsx`
**Description**: Page for viewing execution history with filtering
**Actions**:
- Use `useExecutions()` hook
- Display table of executions with columns: timestamp, workflow name, executed by, status, duration
- Add filters: status dropdown (All/Pending/Running/Success/Failed), workflow name input
- Add "My Executions" toggle → switches to user-scoped query
- Click row → navigate to execution details page
- Color-code status (green=Success, red=Failed, yellow=Running, gray=Pending)
- Auto-refresh every 10 seconds for Running executions
- Pagination or infinite scroll

**Dependencies**: T001, T081
**Test Coverage**: None
**Estimated Time**: 3.5 hours

---

### T083 [US8] - Client: Build ExecutionDetailsPage UI component
**File**: `client/src/pages/ExecutionDetailsPage.tsx`
**Description**: Page for viewing detailed execution information
**Actions**:
- Accept `executionId` from route parameters
- Fetch execution details using `getExecution(executionId, orgId)`
- Display:
  - Execution ID, workflow name, status badge
  - Executed by user, timestamp, duration
  - Input parameters (formatted JSON)
  - Output result (formatted JSON) or error message
  - Link to associated form (if formId present)
- Add "Re-run" button (navigates to form submission page with pre-filled data)
- Add "View Logs" button (if logs available)

**Dependencies**: T001, T080
**Test Coverage**: None
**Estimated Time**: 2.5 hours

---

## Phase 11: Polish & Integration

**Goal**: Cross-cutting concerns, documentation, error handling, deployment preparation

**Checkpoint**: ✅ All components integrated, documentation complete, ready for deployment

### T084 [Polish] - Add global error handling to all backend endpoints
**File**: `management-api/function_app.py`, `workflow-engine/function_app.py`
**Description**: Centralized error handling for consistent API responses
**Actions**:
- Add global exception handler in function app
- Catch all unhandled exceptions
- Return structured error response: `{"error": "...", "message": "...", "details": {...}}`
- Log errors with stack traces
- Differentiate between expected errors (400, 404) and unexpected errors (500)

**Dependencies**: T010
**Test Coverage**: Integration test (trigger error, verify response format)
**Estimated Time**: 1.5 hours

---

### T085 [Polish] [P] - Implement logging and monitoring
**File**: All backend files
**Description**: Add structured logging for observability
**Actions**:
- Use Python `logging` module
- Log all HTTP requests (method, path, user, org, duration)
- Log workflow executions (start, end, status)
- Log errors with stack traces
- Configure log level from environment variables
- Integrate with Azure Application Insights (optional)

**Dependencies**: All backend tasks
**Test Coverage**: None (logging infrastructure)
**Estimated Time**: 2 hours

---

### T086 [Polish] [P] - Add loading states and error handling to all client pages
**File**: All client page components
**Description**: Improve UX with consistent loading and error states
**Actions**:
- Add loading spinners for all API calls
- Add error messages for failed API calls
- Add retry buttons for failed requests
- Add empty states for lists (e.g., "No organizations yet")
- Add success toasts for CRUD operations

**Dependencies**: All client tasks
**Test Coverage**: None
**Estimated Time**: 3 hours

---

### T087 [Polish] - Create client routing configuration
**File**: `client/src/App.tsx`
**Description**: Set up React Router with all pages
**Actions**:
- Install `react-router-dom`
- Configure routes:
  - `/` → OrganizationsPage
  - `/organizations/:orgId` → OrganizationConfigPage
  - `/permissions` → PermissionsPage
  - `/forms` → List of forms (new page or reuse FormBuilderPage)
  - `/forms/new` → FormBuilderPage (create mode)
  - `/forms/:formId/edit` → FormBuilderPage (edit mode)
  - `/forms/:formId/submit` → FormSubmissionPage
  - `/executions` → ExecutionHistoryPage
  - `/executions/:executionId` → ExecutionDetailsPage
- Add navigation menu with links
- Add protected routes (require authentication)

**Dependencies**: T033, T025, T026, T036, T070, T073, T082, T083
**Test Coverage**: None
**Estimated Time**: 2 hours

---

### T088 [Polish] - Update quickstart.md with real implementation details
**File**: `specs/001-complete-mvp-for/quickstart.md`
**Description**: Update developer guide with actual file paths and code examples from implementation
**Actions**:
- Update project structure to match actual implementation
- Add real code examples from implemented workflows and data providers
- Update environment variable examples
- Add troubleshooting section with actual errors encountered
- Verify all commands work

**Dependencies**: All implementation tasks
**Test Coverage**: None (documentation)
**Estimated Time**: 2 hours

---

### T089 [Polish] - Create deployment documentation
**File**: `docs/deployment.md` (new file)
**Description**: Document how to deploy all three components to Azure
**Actions**:
- Document Azure resources needed (Functions App x2, Static Web App, Storage Account, Key Vault)
- Provide ARM templates or Bicep files for infrastructure-as-code
- Document environment variable configuration for production
- Document CI/CD pipeline setup (GitHub Actions)
- Document DNS and custom domain setup
- Document secret management in production

**Dependencies**: All implementation tasks
**Test Coverage**: None (documentation)
**Estimated Time**: 3 hours

---

### T090 [Polish] - End-to-end integration test
**File**: `management-api/tests/e2e/test_full_workflow.py` (new directory)
**Description**: Test complete user flow from org creation to workflow execution
**Actions**:
- Create organization via API
- Grant user permissions via API
- Create form via API
- Execute workflow via form submission
- Verify execution logged
- Query execution history
- Verify all data isolated by org
- Clean up test data

**Dependencies**: All implementation tasks
**Test Coverage**: E2E test for complete platform
**Estimated Time**: 3 hours

---

## Dependency Graph

```
Phase 1 (Setup)
└─> Phase 2 (Foundation)
    └─> Phase 3 (US1: Organizations) ──┐
    └─> Phase 4 (US2: Permissions) ────┤
    └─> Phase 5 (US3: Workflows) ──────┤
                                        ├─> Phase 6 (US7: Execution)
                                        │       │
                                        │       └─> Phase 7 (US4: Data Providers)
                                        │                   │
                                        └───────────────────┴─> Phase 8 (US5: Form Builder)
                                                                        │
                                                                        └─> Phase 9 (US6: Form Renderer)
                                                                                    │
                                                                                    └─> Phase 10 (US8: Execution History)
                                                                                                │
                                                                                                └─> Phase 11 (Polish)
```

**Critical Path**: Setup → Foundation → Organizations → Workflows → Execution → Data Providers → Forms → Form Renderer → Polish

**Parallelizable Phases** (after Foundation):
- Phase 3 (Organizations), Phase 4 (Permissions), Phase 5 (Workflows) can be developed in parallel
- Phase 8 (Forms) and Phase 10 (Execution History) can be developed in parallel after Phase 6

---

## Parallel Execution Examples

### Example 1: Foundation Phase (Phase 2)

**Can run in parallel**:
- T006 (TableStorageService) + T007 (Pydantic models) + T011 (Key Vault client)
- Once T006 completes: T008 (auth middleware) + T010 (blueprints)
- Once T006 + T008 complete: T009 (permissions middleware)

**Sequential**:
- T009 must wait for T006 + T008

---

### Example 2: P1 User Stories (Phases 3-6)

**Can run in parallel** (different teams):
- Team A: Phase 3 (US1: Organizations) - T012-T026
- Team B: Phase 4 (US2: Permissions) - T027-T036
- Team C: Phase 5 (US3: Workflows) - T037-T045

**Must be sequential**:
- Phase 6 (US7: Execution) depends on Phase 5 (workflows) and Phase 3 (organizations)

---

### Example 3: Within User Story 1 (Organizations)

**Can run in parallel**:
- T013 (GET organizations) + T014 (POST organizations) + T015 (GET org by ID) - all different endpoints
- T022 (TypeScript types) + T023 (API service) - client-side, independent of backend

**Sequential**:
- T012 (contract tests) must complete before T013-T017 (implementations) - TDD approach
- T025 (OrganizationsPage UI) depends on T024 (useOrganizations hook)

---

## Implementation Strategy

### Recommended MVP Scope (Weeks 1-2)

Implement **only P1 user stories** for minimum viable product:

**Week 1**:
- Phase 1: Project Setup (T001-T005) - Day 1
- Phase 2: Foundational Infrastructure (T006-T011) - Days 2-3
- Phase 3: User Story 1 - Organizations (T012-T026) - Days 4-5

**Week 2**:
- Phase 4: User Story 2 - Permissions (T027-T036) - Days 1-2
- Phase 5: User Story 3 - Workflows (T037-T045) - Days 3-4
- Phase 6: User Story 7 - Execution (T046-T054) - Day 5

**Result**: Working platform where developers can create workflows, admins can manage orgs/permissions, workflows execute with org context.

### Extended MVP (Weeks 3-4)

Add **P2 user stories** for user-facing forms:

**Week 3**:
- Phase 7: User Story 4 - Data Providers (T055-T060) - Day 1
- Phase 8: User Story 5 - Form Builder (T061-T071) - Days 2-4
- Phase 9: User Story 6 - Form Renderer (T072-T074) - Day 5

**Week 4**:
- Phase 10: User Story 8 - Execution History (T075-T083) - Days 1-3
- Phase 11: Polish & Integration (T084-T090) - Days 4-5

**Result**: Complete MVP with forms, execution history, and production-ready polish.

---

## Validation Checkpoints

After each phase, validate:

1. **After Phase 2**: Can insert/query Table Storage, validate tokens, use Pydantic models
2. **After Phase 3**: Can create org, add config, verify org isolation
3. **After Phase 4**: Can grant permissions, login enforces org access
4. **After Phase 5**: Workflows auto-register, metadata endpoint works
5. **After Phase 6**: Can execute workflow via HTTP, context loads correctly, execution logged
6. **After Phase 7**: Data providers return options, caching works
7. **After Phase 8**: Can create form with multiple field types, link to workflow
8. **After Phase 9**: Can render form, submit, execute workflow
9. **After Phase 10**: Can view execution history, filter results
10. **After Phase 11**: All pages work, errors handled gracefully, ready for deployment

---

## Next Steps

1. **Review this task list** with team and stakeholders
2. **Assign tasks** to developers based on expertise (frontend vs. backend)
3. **Set up repositories** and run Phase 1 tasks
4. **Start with Foundation phase** (all user stories depend on this)
5. **Follow TDD approach**: Write contract tests before implementation for each user story
6. **Use parallel execution** where possible (different files = parallelizable)
7. **Run validation checkpoints** after each phase
8. **Prioritize P1 stories** for MVP (Phases 1-6)
9. **Expand to P2 stories** once P1 is stable (Phases 7-9)
10. **Polish and deploy** (Phase 11)

---

**Ready for implementation!** 🚀
