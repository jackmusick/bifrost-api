import { useState, useEffect, useMemo } from 'react'
import { useNavigate, useParams } from 'react-router-dom'
import { ArrowLeft, Save, Eye, Pencil, Info, Play } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Badge } from '@/components/ui/badge'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { ContextViewer } from '@/components/ui/context-viewer'
import { useForm as useFormQuery, useCreateForm, useUpdateForm } from '@/hooks/useForms'
import { formsService } from '@/services/forms'
import { useWorkflowsMetadata } from '@/hooks/useWorkflows'
import { useMutation } from '@tanstack/react-query'
import { FormInfoDialog } from '@/components/forms/FormInfoDialog'
import { FieldsPanelDnD } from '@/components/forms/FieldsPanelDnD'
import { FormPreview } from '@/components/forms/FormPreview'
import { WorkflowParametersForm } from '@/components/workflows/WorkflowParametersForm'
import { useOrgScope } from '@/contexts/OrgScopeContext'
import { useAuth } from '@/hooks/useAuth'
import type { components } from '@/lib/v1'
type FormField = components['schemas']['FormField']
type CreateFormRequest = components['schemas']['CreateFormRequest']
type UpdateFormRequest = components['schemas']['UpdateFormRequest']
import { toast } from 'sonner'

export function FormBuilder() {
  const navigate = useNavigate()
  const { formId } = useParams()
  const isEditing = !!formId
  const { isGlobalScope, scope } = useOrgScope()
  const { user } = useAuth()

  const { data: existingForm } = useFormQuery(formId)
  const createForm = useCreateForm()
  const updateForm = useUpdateForm()
  const { data: workflowsMetadata } = useWorkflowsMetadata()

  // Mutation for testing form startup workflow
  const testStartupWorkflow = useMutation({
    mutationFn: async ({ formId, inputData }: { formId: string; inputData?: Record<string, unknown> }) => {
      return await formsService.executeFormStartup(formId, inputData)
    },
  })

  // Form state
  const [formName, setFormName] = useState('')
  const [formDescription, setFormDescription] = useState('')
  const [linkedWorkflow, setLinkedWorkflow] = useState('')
  const [isGlobal, setIsGlobal] = useState(isGlobalScope) // Default based on current scope
  const [launchWorkflowId, setLaunchWorkflowId] = useState<string | null>(null)
  const [defaultLaunchParams, setDefaultLaunchParams] = useState<Record<string, unknown> | null>(null)
  const [fields, setFields] = useState<FormField[]>([])
  const [isInfoDialogOpen, setIsInfoDialogOpen] = useState(false)
  const [isContextDialogOpen, setIsContextDialogOpen] = useState(false)
  const [workflowResultsDialogOpen, setWorkflowResultsDialogOpen] = useState(false)
  const [workflowParamsDialogOpen, setWorkflowParamsDialogOpen] = useState(false)
  const [workflowResults, setWorkflowResults] = useState<Record<string, unknown> | null>(null)

  // Load existing form data
  useEffect(() => {
    if (existingForm && existingForm.formSchema) {
      setFormName(existingForm.name)
      setFormDescription(existingForm.description || '')
      setLinkedWorkflow(existingForm.linkedWorkflow)
      setIsGlobal(existingForm.isGlobal)
      setLaunchWorkflowId(existingForm.launchWorkflowId || null)
      setDefaultLaunchParams(existingForm.defaultLaunchParams || null)
      setFields(existingForm.formSchema.fields || [])
    }
  }, [existingForm])

  // Update isGlobal when scope changes (only for new forms)
  useEffect(() => {
    if (!isEditing) {
      setIsGlobal(isGlobalScope)
    }
  }, [isGlobalScope, isEditing])

  // Open info dialog automatically for new forms
  useEffect(() => {
    if (!isEditing && !formName) {
      setIsInfoDialogOpen(true)
    }
  }, [isEditing, formName])

  const handleSave = async () => {
    try {
      // Auto-generate allowedQueryParams from fields that have allowAsQueryParam enabled
      const autoGeneratedParams = fields
        .filter(field => field.allowAsQueryParam === true)
        .map(field => field.name)

      if (isEditing && formId) {
        const updateRequest: UpdateFormRequest = {
          name: formName,
          description: formDescription || null,
          linkedWorkflow,
          formSchema: { fields },
          isActive: true,
          // NEW MVP fields
          launchWorkflowId: launchWorkflowId || null,
          allowedQueryParams: autoGeneratedParams.length > 0 ? autoGeneratedParams : null,
          defaultLaunchParams: defaultLaunchParams,
        }
        await updateForm.mutateAsync({ formId, request: updateRequest })
        toast.success('Form updated successfully')
      } else {
        const createRequest: CreateFormRequest = {
          name: formName,
          description: formDescription || null,
          linkedWorkflow,
          formSchema: { fields },
          isGlobal,
          isPublic: false,
          // NEW MVP fields
          launchWorkflowId: launchWorkflowId || null,
          allowedQueryParams: autoGeneratedParams.length > 0 ? autoGeneratedParams : null,
          defaultLaunchParams: defaultLaunchParams,
        }
        await createForm.mutateAsync(createRequest)
        toast.success('Form created successfully')
      }

      navigate('/forms')
    } catch (error: unknown) {
      console.error('Failed to save form:', error)

      // Extract error message from response
      const errorResponse = error as { response?: { data?: { message?: string; details?: { errors?: { loc: string[], msg: string }[] } } } } & Error
      const errorMessage = errorResponse?.response?.data?.message || errorResponse?.message || 'Failed to save form'
      const errorDetails = errorResponse?.response?.data?.details

      if (errorDetails?.errors) {
        // Show validation errors with better formatting
        const validationErrors = errorDetails.errors
          .map((err: { loc: string[], msg: string }) => `${err.loc.join('.')}: ${err.msg}`)
          .join('\n')
        toast.error(`Validation Error\n${validationErrors}`, {
          duration: 8000, // 8 seconds for validation errors
        })
      } else {
        // For long error messages (like parameter validation), increase duration
        toast.error(errorMessage, {
          duration: errorMessage.length > 150 ? 10000 : 6000, // 10s for long messages, 6s otherwise
        })
      }
    }
  }

  const isSaveDisabled = !formName || !linkedWorkflow || fields.length === 0

  // Handle test launch workflow execution
  const handleTestLaunchWorkflow = async (workflowParams?: Record<string, unknown>) => {
    if (!launchWorkflowId) {
      toast.error('No launch workflow configured')
      return
    }

    // Need a saved form ID to test
    if (!formId) {
      toast.error('Please save the form first before testing the launch workflow')
      return
    }

    try {
      // Use workflow params directly (just like workflow execution)
      const result = await testStartupWorkflow.mutateAsync({
        formId,
        inputData: workflowParams || {},
      })

      setWorkflowResults(result.result as Record<string, unknown>)
      setWorkflowResultsDialogOpen(true)
      toast.success('Launch workflow executed successfully')
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to execute launch workflow'
      toast.error(errorMessage)
      console.error('Failed to execute launch workflow:', error)
    }
  }

  // Get workflow metadata for launch workflow
  const launchWorkflow = workflowsMetadata?.workflows?.find(
    w => w.name === launchWorkflowId
  )
  const launchWorkflowParameters = launchWorkflow?.parameters || []

  // Build real context preview based on current user and form state
  const previewContext = useMemo(() => {
    // Build workflow context with real user data or workflow results if available
    const workflowContext = workflowResults || {
      user_id: user?.userId || 'user-123',
      user_email: user?.userDetails || 'user@example.com',
      organization_id: scope.orgId || null,
    }

    // Build query context from fields with allowAsQueryParam enabled
    const queryContext: Record<string, string> = {}
    fields
      .filter(field => field.allowAsQueryParam)
      .forEach(field => {
        queryContext[field.name] = `<${field.label.toLowerCase().replace(/\s+/g, '_')}>`
      })

    return {
      workflow: workflowContext,
      query: queryContext,
      field: {},
    }
  }, [user, scope.orgId, fields, workflowResults])

  return (
    <div className="flex flex-col h-full -m-6 lg:-m-8 p-6 lg:p-8">
      <div className="flex items-center justify-between flex-shrink-0 mb-6">
        <div>
          <h1 className="text-4xl font-extrabold tracking-tight">
            {formName || (isEditing ? 'Edit Form' : 'New Form')}
          </h1>
          <div className="mt-2 flex items-center gap-2">
            {linkedWorkflow && (
              <Badge variant="outline" className="font-mono text-xs">
                {linkedWorkflow}
              </Badge>
            )}
            {isGlobal && (
              <Badge variant="secondary" className="text-xs">
                Global
              </Badge>
            )}
            {formDescription && (
              <p className="text-sm text-muted-foreground">{formDescription}</p>
            )}
          </div>
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigate('/forms')}
            title="Back to Forms"
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>
          <div className="flex items-center">
            <Button
              variant="outline"
              size="icon"
              onClick={() => setIsInfoDialogOpen(true)}
              title={formName ? 'Edit Info' : 'Set Info'}
              className="rounded-r-none"
            >
              <Pencil className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={() => setIsContextDialogOpen(true)}
              title="Show Context"
              className="rounded-none border-l-0"
            >
              <Info className="h-4 w-4" />
            </Button>
            {launchWorkflowId && (
              <Button
                variant="outline"
                size="icon"
                onClick={() => {
                  if (launchWorkflowParameters.length > 0) {
                    setWorkflowParamsDialogOpen(true)
                  } else {
                    handleTestLaunchWorkflow()
                  }
                }}
                disabled={testStartupWorkflow.isPending || !formId}
                title={testStartupWorkflow.isPending ? 'Testing...' : 'Test Launch Workflow'}
                className="rounded-none border-l-0"
              >
                <Play className="h-4 w-4" />
              </Button>
            )}
            <Button
              variant="outline"
              size="icon"
              onClick={handleSave}
              disabled={isSaveDisabled || createForm.isPending || updateForm.isPending}
              title={createForm.isPending || updateForm.isPending ? 'Saving...' : 'Save Form'}
              className={launchWorkflowId ? 'rounded-l-none border-l-0' : 'rounded-l-none border-l-0'}
            >
              <Save className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>

      <Tabs defaultValue="builder" className="w-full flex-1 flex flex-col overflow-hidden">
        <TabsList className="flex-shrink-0">
          <TabsTrigger value="builder">Form Builder</TabsTrigger>
          <TabsTrigger value="preview">
            <Eye className="mr-2 h-4 w-4" />
            Preview
          </TabsTrigger>
        </TabsList>

        <TabsContent value="builder" className="flex-1 overflow-hidden data-[state=active]:flex">
          <FieldsPanelDnD
            fields={fields}
            setFields={setFields}
            linkedWorkflow={linkedWorkflow}
            previewContext={previewContext}
          />
        </TabsContent>

        <TabsContent value="preview" className="flex-1 overflow-auto data-[state=active]:block">
          <FormPreview
            formName={formName}
            formDescription={formDescription}
            fields={fields}
          />
        </TabsContent>
      </Tabs>

      <FormInfoDialog
        open={isInfoDialogOpen}
        onClose={() => setIsInfoDialogOpen(false)}
        onSave={(info) => {
          setFormName(info.formName)
          setFormDescription(info.formDescription)
          setLinkedWorkflow(info.linkedWorkflow)
          setLaunchWorkflowId(info.launchWorkflowId)
          setDefaultLaunchParams(info.defaultLaunchParams)
        }}
        initialData={{
          formName,
          formDescription,
          linkedWorkflow,
          launchWorkflowId,
          defaultLaunchParams,
        }}
      />

      <Dialog open={isContextDialogOpen} onOpenChange={setIsContextDialogOpen}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>Form Context Preview</DialogTitle>
            <DialogDescription>
              Preview of context available to form fields at runtime. Workflow values shown are based on your current session{workflowResults ? ' and test launch workflow results' : ''}.
            </DialogDescription>
          </DialogHeader>
          <ContextViewer
            context={previewContext}
            maxHeight="500px"
            fieldNames={fields.map(f => f.name)}
          />
        </DialogContent>
      </Dialog>

      <Dialog open={workflowParamsDialogOpen} onOpenChange={setWorkflowParamsDialogOpen}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>Test Launch Workflow</DialogTitle>
            <DialogDescription>
              Enter parameters for {launchWorkflowId} to test with real workflow data.
            </DialogDescription>
          </DialogHeader>
          <WorkflowParametersForm
            parameters={launchWorkflowParameters}
            onExecute={async (params) => {
              await handleTestLaunchWorkflow(params)
              setWorkflowParamsDialogOpen(false)
            }}
            isExecuting={testStartupWorkflow.isPending}
            executeButtonText="Run & View Results"
          />
        </DialogContent>
      </Dialog>

      <Dialog open={workflowResultsDialogOpen} onOpenChange={setWorkflowResultsDialogOpen}>
        <DialogContent className="sm:max-w-[700px]">
          <DialogHeader>
            <DialogTitle>Launch Workflow Test Results</DialogTitle>
            <DialogDescription>
              Results from executing the launch workflow. This data will be available in context.workflow when the form loads.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div className="p-4 bg-muted rounded-md">
              <pre className="text-xs overflow-auto max-h-[400px]">
                {JSON.stringify(workflowResults, null, 2)}
              </pre>
            </div>
            <p className="text-sm text-muted-foreground">
              The context preview has been updated with these results. You can now test field visibility expressions and HTML templates with real workflow data.
            </p>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}
